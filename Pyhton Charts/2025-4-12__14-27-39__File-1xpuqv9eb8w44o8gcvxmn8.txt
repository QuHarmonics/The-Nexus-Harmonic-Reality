Conversation URL:
https://chatgpt.com/c/67f95edf-b4f0-8011-bf7d-1f0be7727312

Title:


Prompt:
import hashlib
import random
import matplotlib.pyplot as plt

# Constants
SHA_HEX_LENGTH = 64  # SHA-256 outputs 256 bits = 64 hex characters = 32 bytes

def sha256_hex(data: bytes) -> str:
    return hashlib.sha256(data).hexdigest()

def generate_random_hex(length=SHA_HEX_LENGTH) -> str:
    return ''.join(random.choice('0123456789abcdef') for _ in range(length))

def mirror_index(i, total):
    return total - 1 - i

def recursive_harmonize(input_hex: str, history=None, depth=0, locked=None):
    if locked is None:
        locked = set()
    if history is None:
        history = []

    input_bytes = bytes.fromhex(input_hex)
    hash_hex = sha256_hex(input_bytes)

    # Exit if match
    if input_hex == hash_hex[::-1]:
        history.append((input_hex, hash_hex, depth))
        return input_hex, hash_hex, history

    # Recursive center-out approach
    mid = len(input_hex) // 2
    changed = False
    input_list = list(input_hex)

    for offset in range(mid + 1):
        i = mid - offset
        j = mirror_index(i, len(input_hex))

        if i in locked or j in locked:
            continue

        # Adjust input[i] to move toward hash[j] (mirrored)
        if input_list[i] != hash_hex[j]:
            input_list[i] = hash_hex[j]
            locked.add(i)
            changed = True
            break  # Only one mutation per recursion

        # Mirror symmetry
        if input_list[j] != hash_hex[i]:
            input_list[j] = hash_hex[i]
            locked.add(j)
            changed = True
            break

    # If no change, lock all and finish
    if not changed:
        history.append((input_hex, hash_hex, depth))
        return input_hex, hash_hex, history

    # Recurse with new input
    new_input = ''.join(input_list)
    history.append((new_input, sha256_hex(bytes.fromhex(new_input)), depth))
    return recursive_harmonize(new_input, history, depth + 1, locked)

# Generate initial random hex input of SHA length
initial_input = generate_random_hex(SHA_HEX_LENGTH)

# Run recursive harmonizer
final_input, final_hash, history = recursive_harmonize(initial_input)

# Plot progression
match_scores = [
    sum(1 for a, b in zip(hx, sha[::-1]) if a == b) for hx, sha, _ in history
]

plt.figure(figsize=(10, 4))
plt.plot(match_scores, marker='o')
plt.title("Center-Out SHA Harmony Progression")
plt.xlabel("Recursion Step")
plt.ylabel("Reversed SHA Match Score")
plt.grid(True)
plt.tight_layout()
plt.show()

final_input, final_hash, match_scores[-1], len(history)