Conversation URL:
https://chatgpt.com/c/67b6f214-dd30-8011-aefd-9439df008548

Title:


Prompt:
# Step 1: Track which specific byte positions stabilize the most across all iterations

# Convert hashes into byte lists for position tracking
hash_bytes_list = [
    sha256_hello_1_bytes, sha256_hello_2_bytes, sha256_hello_3_bytes,
    sha256_hello_4_bytes, sha256_hello_5_bytes, sha256_hello_6_bytes,
    sha256_hello_7_bytes, sha256_hello_8_bytes, sha256_hello_9_bytes
]

# Count how many times each byte position remains the same across iterations
stable_positions = [0] * 32  # SHA-256 produces 32-byte outputs

for i in range(32):  # Iterate over byte positions in SHA-256 output
    first_value = hash_bytes_list[0][i]  # Take the first hash as reference
    stable_count = sum(1 for hash_bytes in hash_bytes_list if hash_bytes[i] == first_value)
    stable_positions[i] = stable_count

# Plot the stability of each byte position
plt.figure(figsize=(12, 6))
plt.bar(range(32), stable_positions, color='red', alpha=0.7)
plt.title("Byte Stability Across SHA-256 Iterations")
plt.xlabel("Byte Position (0-31)")
plt.ylabel("Times Byte Remained Unchanged")
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# Step 2: Test if specific input patterns affect entropy and byte clustering

# Define test patterns for hashing
test_patterns = [
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",  # Repeating A
    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",  # Repeating F
    "1234567890ABCDEF1234567890ABCDEF",  # Sequential Hex
    "00000000000000000000000000000000"   # All Zeroes
]

# Hash each test pattern using SHA-256 and analyze frequency
test_hashes = [bytes.fromhex(test_pattern) for test_pattern in test_patterns]
test_frequencies = [Counter(test_hash) for test_hash in test_hashes]

# Plot frequency distributions for test patterns
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

colors = ['blue', 'green', 'purple', 'orange']
titles = ["Repeating A", "Repeating F", "Sequential Hex", "All Zeroes"]

for i, ax in enumerate(axes.flatten()):
    sorted_bytes = sorted(test_frequencies[i].keys())
    sorted_frequencies = [test_frequencies[i][b] for b in sorted_bytes]

    ax.bar(sorted_bytes, sorted_frequencies, color=colors[i], alpha=0.7)
    ax.set_title(f"Byte Frequency: {titles[i]}")
    ax.set_xlabel("Byte Value (0-255)")
    ax.set_ylabel("Frequency")
    ax.grid(axis='y', linestyle='--', alpha=0.7)

plt.tight_layout()
plt.show()

# Step 3: Check entropy fluctuation alignment with universal harmonic ratios

# Define expected harmonic entropy fluctuation range (Mark 1 ratios)
harmonic_ratio = 0.35  # Known universal ratio in Mark 1
entropy_values = [entropy_hello_1, entropy_hello_2, entropy_hello_3,
                  entropy_hello_4, entropy_hello_5, entropy_hello_6,
                  entropy_hello_7, entropy_hello_8, entropy_hello_9]

# Compute expected harmonic fluctuation
harmonic_adjusted = [entropy_values[0] * (1 - harmonic_ratio * i) for i in range(len(entropy_values))]

# Plot actual entropy vs. harmonic predicted entropy
plt.figure(figsize=(12, 6))
plt.plot(range(len(entropy_values)), entropy_values, marker='o', linestyle='-', label="Actual Entropy", color='blue')
plt.plot(range(len(harmonic_adjusted)), harmonic_adjusted, marker='x', linestyle='--', label="Harmonic Expected", color='red')
plt.title("SHA-256 Entropy Fluctuation vs. Harmonic Expectation")
plt.xlabel("Hash Iteration")
plt.ylabel("Entropy")
plt.legend()
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()