Conversation URL:
https://chatgpt.com/c/680df8d1-c038-8011-b644-837635a78eee

Title:
Composite Frontier (ε=1.0, fixed, bias=True)

Prompt:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Stream generators
def generate_random_walk(N=1000, seed=0):
    np.random.seed(seed)
    return np.cumsum(np.random.randn(N))

def generate_sinusoid(N=1000, freq=5, amplitude=1.0, phase=0.0):
    t = np.linspace(0, 2 * np.pi, N)
    return amplitude * np.sin(freq * t + phase)

def generate_bursty(N=1000, p_burst=0.05, burst_scale=5.0, noise_scale=0.2, seed=42):
    np.random.seed(seed)
    deltas = []
    for _ in range(N):
        if np.random.rand() < p_burst:
            deltas.append(np.random.randn() * burst_scale)
        else:
            deltas.append(np.random.randn() * noise_scale)
    return np.cumsum(deltas)

# Compression function
def novelty_motif_compression(stream, base_eps, adaptive, min_len, max_len, bias, k=0.35, window_vol=10):
    deltas = np.diff(stream)
    N = len(deltas)
    vol = np.array([np.std(deltas[max(0, i-window_vol):i+1]) for i in range(N)])
    
    # Journal by epsilon
    journal = [d for i, d in enumerate(deltas) if abs(d) > (base_eps * vol[i] if adaptive else base_eps)]
    
    # Motif compression with novelty checkpoints
    motif_dict = {}
    next_id = 0
    tokens = []
    storage_tokens = 0
    checkpoints = 0
    pos = 0
    
    while pos < len(journal):
        matched = False
        for L in range(max_len, min_len-1, -1):
            if pos + L <= len(journal):
                seq = tuple(journal[pos:pos+L])
                if seq in motif_dict:
                    tokens.append(('M', motif_dict[seq]))
                    storage_tokens += 1
                    pos += L
                    matched = True
                    break
        if matched:
            continue
        
        # Literal delta
        tokens.append(('D', journal[pos]))
        storage_tokens += 1
        
        # Build candidates
        candidates = [tuple(journal[pos:pos+L])
                      for L in range(min_len, max_len+1)
                      if pos + L <= len(journal)]
        
        if candidates:
            if bias:
                # pick motif closest to k
                best = min(candidates, key=lambda s: abs(np.mean(s) - k))
                if best not in motif_dict:
                    motif_dict[best] = next_id
                    next_id += 1
                    checkpoints += 1
            else:
                first = True
                for seq in candidates:
                    if seq not in motif_dict:
                        motif_dict[seq] = next_id
                        next_id += 1
                        if first:
                            checkpoints += 1
                            first = False
        pos += 1
    
    total_storage = storage_tokens + checkpoints
    
    # Reconstruction
    reconstructed = np.zeros(len(stream))
    idx = 1
    inv_motifs = {v: k for k, v in motif_dict.items()}
    for typ, val in tokens:
        if typ == 'M':
            for d in inv_motifs[val]:
                reconstructed[idx] = reconstructed[idx-1] + d
                idx += 1
        else:
            reconstructed[idx] = reconstructed[idx-1] + val
            idx += 1
    
    rmse = np.sqrt(np.mean((reconstructed - stream)**2))
    return total_storage / N, rmse

# Settings
epsilons = [0.5, 1.0, 2.0, 4.0]
schemes = {'fixed': False, 'adaptive': True}
motif_lengths = list(range(2, 9))
bias_options = [False, True]

# Streams
streams = {
    'random': generate_random_walk(),
    'sinusoid': generate_sinusoid(),
    'bursty': generate_bursty()
}

# Run sweep for bursty
bursty_results = []
for scheme_name, adaptive in schemes.items():
    for eps in epsilons:
        for min_len in motif_lengths:
            max_len = min_len + 3
            for bias in bias_options:
                sr, rmse = novelty_motif_compression(
                    streams['bursty'], eps, adaptive, min_len, max_len, bias
                )
                bursty_results.append({
                    'scheme': scheme_name,
                    'base_eps': eps,
                    'min_len': min_len,
                    'bias': bias,
                    'storage_ratio': sr,
                    'rmse': rmse
                })
df_bursty = pd.DataFrame(bursty_results)

# Plot 2x2 panels for bursty
for bias in bias_options:
    fig, axs = plt.subplots(2, 2, figsize=(12,8), sharex=True, sharey=True)
    fig.suptitle(f'Novelty + Motif Sweep on Bursty (bias={bias})', fontsize=16)
    for idx, eps in enumerate(epsilons):
        ax = axs[idx//2, idx%2]
        subset = df_bursty[(df_bursty['base_eps']==eps) & (df_bursty['bias']==bias)]
        for min_len in motif_lengths:
            for scheme_name, marker in [('fixed','o'), ('adaptive','x')]:
                df_sub = subset[(subset['min_len']==min_len) & (subset['scheme']==scheme_name)]
                ax.scatter(df_sub['storage_ratio'], df_sub['rmse'],
                           label=f'len={min_len},{scheme_name}', marker=marker, alpha=0.7)
        ax.set_title(f'ε = {eps}')
        ax.set_xlabel('Total Storage Ratio')
        ax.set_ylabel('RMSE')
        ax.grid(True)
        if idx == 0:
            ax.legend(loc='upper right', bbox_to_anchor=(1.3, 1.1))
    plt.tight_layout(rect=[0,0,0.9,0.95])
    plt.show()

# Composite frontier overlay for eps=1.0, bias=True, fixed scheme
plt.figure(figsize=(6,5))
colors = {'random':'red','sinusoid':'blue','bursty':'green'}
for name, stream in streams.items():
    # Run motif sweep for this stream
    composite = []
    for min_len in motif_lengths:
        max_len = min_len + 3
        sr, rmse = novelty_motif_compression(
            streams[name], 1.0, False, min_len, max_len, True
        )
        composite.append((sr, rmse))
    srs, rmses = zip(*composite)
    plt.plot(srs, rmses, '-o', color=colors[name], label=name)

plt.title('Composite Frontier (ε=1.0, fixed, bias=True)')
plt.xlabel('Total Storage Ratio')
plt.ylabel('RMSE')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()