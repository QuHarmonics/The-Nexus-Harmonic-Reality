Conversation URL:
https://chatgpt.com/c/68660489-4854-8011-bdb9-259a66efdde3

Title:
ΔResidue vs. MSB Flip and Predicted Fold-In Events

Prompt:
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# === Generate or load your input data ===
# Simulated input data: each state has both a numeric and hexadecimal representation
np.random.seed(42)
states = np.random.randint(0, 256, size=300)
hex_codes = [f"{x:02x}" for x in states]
df = pd.DataFrame({'state': states, 'hex': hex_codes})

# === Compute Residue (mod 64) and Delta ===
df['residue'] = df['state'] % 64
df['residue_next'] = df['residue'].shift(-1)
df['delta_residue'] = (df['residue_next'] - df['residue']).fillna(0)

# === Compute Bit Pattern and MSB ===
df['bit_pattern'] = df['state'].apply(lambda x: list(map(int, f"{x:08b}")))
df['bit7'] = df['bit_pattern'].apply(lambda bits: bits[0])  # MSB (bit 7)
df['bit6'] = df['bit_pattern'].apply(lambda bits: bits[1])  # Bit 6
df['bit5'] = df['bit_pattern'].apply(lambda bits: bits[2])  # Bit 5
df['bit7_next'] = df['bit7'].shift(-1)
df['msb_flip'] = (df['bit7'] != df['bit7_next']).astype(int)

# === Compute Recursive Hamming signature ===
def hamming(a, b):
    return bin(a ^ b).count('1')

df['state_prev1'] = df['state'].shift(1)
df['state_prev2'] = df['state'].shift(2)
df['state_prev3'] = df['state'].shift(3)

df['hamm_1'] = df.apply(lambda r: hamming(int(r['state']), int(r['state_prev1'])) if pd.notnull(r['state_prev1']) else 0, axis=1)
df['hamm_2'] = df.apply(lambda r: hamming(int(r['state_prev1']), int(r['state_prev2'])) if pd.notnull(r['state_prev2']) else 0, axis=1)
df['hamm_3'] = df.apply(lambda r: hamming(int(r['state_prev2']), int(r['state_prev3'])) if pd.notnull(r['state_prev3']) else 0, axis=1)

# === Rolling ΔResidue Compression Field ===
df['delta_rolling'] = df['delta_residue'].rolling(window=3).sum().fillna(0)

# === Phase Fold-In Detection (no "if-then-everything" logic) ===
# Construct a harmonic potential using multiple subtle recursive factors
df['fold_potential'] = (
    (1 - df['bit7']) * 0.3 +
    (1 - df['bit6']) * 0.2 +
    (1 - df['bit5']) * 0.2 +
    (3 - df['hamm_1']) * 0.1 +
    (3 - df['hamm_2']) * 0.1 +
    (-df['delta_rolling'] / 30.0)
)

# Normalize and set threshold for predicted fold-in
fold_threshold = df['fold_potential'].mean() + df['fold_potential'].std()
df['predict_fold'] = (df['fold_potential'] > fold_threshold).astype(int)

# === Evaluation ===
tp = ((df['predict_fold'] == 1) & (df['msb_flip'] == 1)).sum()
fp = ((df['predict_fold'] == 1) & (df['msb_flip'] == 0)).sum()
fn = ((df['predict_fold'] == 0) & (df['msb_flip'] == 1)).sum()
precision = tp / (tp + fp) if (tp + fp) > 0 else 0
recall = tp / (tp + fn) if (tp + fn) > 0 else 0

# === Plot ===
plt.figure(figsize=(12, 6))
plt.plot(df['delta_residue'], label='ΔResidue', color='blue')
plt.scatter(df[df['msb_flip'] == 1].index, df[df['msb_flip'] == 1]['delta_residue'], color='red', label='MSB Flip', marker='x', zorder=5)
plt.scatter(df[df['predict_fold'] == 1].index, df[df['predict_fold'] == 1]['delta_residue'], color='green', label='Predicted Fold-In', marker='o', facecolors='none', edgecolors='green', zorder=4)
plt.axhline(30, color='gray', linestyle='--', alpha=0.5, label='ΔResidue Threshold 30')
plt.xlabel('Timestep')
plt.ylabel('ΔResidue')
plt.title('ΔResidue vs. MSB Flip and Predicted Fold-In Events')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import ace_tools as tools; tools.display_dataframe_to_user(name="Fold-In Alignment Detection", dataframe=df[['state', 'hex', 'delta_residue', 'bit7', 'bit6', 'bit5', 'hamm_1', 'hamm_2', 'delta_rolling', 'fold_potential', 'predict_fold', 'msb_flip']])

precision, recall, tp, fp, fn