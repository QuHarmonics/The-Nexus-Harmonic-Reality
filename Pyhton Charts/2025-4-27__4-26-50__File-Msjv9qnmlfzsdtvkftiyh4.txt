Conversation URL:
https://chatgpt.com/c/680db4f8-2748-8011-ac20-c687d521af22

Title:


Prompt:
import numpy as np
import matplotlib.pyplot as plt
from hashlib import sha256

# 1) Create the field as before
def hash_to_field(hex_digest: str, width: int = 128) -> np.ndarray:
    values = [int(ch, 16) for ch in hex_digest.strip()]
    reps = (width * ((len(values) + width - 1) // width)) // len(values) + 1
    values = (values * reps)[: width * ((len(values) + width - 1) // width)]
    field = np.array(values, dtype=float).reshape(-1, width)
    return field

# 2) Fix field_gradient to pad when dimensions < 2
def field_gradient(field: np.ndarray) -> tuple[np.ndarray, np.ndarray]:
    h, w = field.shape
    padded = False
    if h < 2:
        field = np.vstack([field, field])
        padded = True
        h = 2
    if w < 2:
        field = np.hstack([field, field])
        padded = True
        w = 2
    dy, dx = np.gradient(field, edge_order=1)
    dx = -dx
    dy = -dy
    if padded:
        # Return only the original shape
        return dx[:field.shape[0]//(2 if field.shape[0]>h else 1), :w], dy[:field.shape[0]//(2 if field.shape[0]>h else 1), :w]
    return dx[:h, :w], dy[:h, :w]

# 3) Plinko drop as before
def drop_probes(field: np.ndarray, n_probes: int = 40, max_steps: int = 250,
                step_size: float = 0.4) -> list[np.ndarray]:
    h, w = field.shape
    gx, gy = field_gradient(field)

    def sample_grad(xf: float, yf: float) -> tuple[float, float]:
        if xf < 0 or yf < 0 or xf > w - 2 or yf > h - 2:
            return (0.0, 0.0)
        x0, y0 = int(xf), int(yf)
        dx1, dy1 = xf - x0, yf - y0
        weights = np.array([[(1-dx1)*(1-dy1), dx1*(1-dy1)],
                            [(1-dx1)*dy1,      dx1*dy1  ]])
        gx_block = gx[y0:y0+2, x0:x0+2]
        gy_block = gy[y0:y0+2, x0:x0+2]
        return (float((weights*gx_block).sum()),
                float((weights*gy_block).sum()))

    paths = []
    rng = np.random.default_rng(123)
    for _ in range(n_probes):
        x, y = rng.uniform(0, w-1), 0.0
        pts = [(x, y)]
        for _ in range(max_steps):
            vx, vy = sample_grad(x, y)
            norm = (vx**2 + vy**2) ** 0.5 + 1e-9
            x += step_size * vx / norm
            y += step_size * vy / norm
            if x < 0 or x >= w or y < 0 or y >= h:
                break
            pts.append((x, y))
        paths.append(np.array(pts))
    return paths

# 4) Demo run
digest = sha256(b"Hello, carrier!").hexdigest()
field = hash_to_field(digest, width=128)
paths = drop_probes(field, n_probes=60, max_steps=300)

# 5) Plot
fig, ax = plt.subplots(figsize=(12, 6))
im = ax.imshow(field, cmap="viridis", origin="upper", interpolation="nearest")
fig.colorbar(im, ax=ax, label="Field value (0–15)")

gdx, gdy = field_gradient(field)
stride = 8
Y, X = np.mgrid[0:field.shape[0]:stride, 0:field.shape[1]:stride]
ax.quiver(X, Y, gdx[::stride, ::stride], gdy[::stride, ::stride],
          color="white", alpha=0.6, scale=100, width=0.002)

for p in paths:
    ax.plot(p[:,0], p[:,1], color="red", alpha=0.6, linewidth=1)

ax.set_title("SHA-256 Field • Drift Vectors • Plinko Paths")
ax.set_xlabel("x")
ax.set_ylabel("y")
ax.set_xlim(0, field.shape[1]-1)
ax.set_ylim(field.shape[0]-1, 0)

plt.tight_layout()