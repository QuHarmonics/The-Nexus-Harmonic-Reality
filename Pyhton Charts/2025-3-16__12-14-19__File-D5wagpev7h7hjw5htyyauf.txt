Conversation URL:
https://chatgpt.com/c/67d65bbe-894c-8011-a014-0ae1ad66087d

Title:


Prompt:
# 2. Test if Sophie Germain & Cousin primes also align with Pi’s harmonic shifts

# Generate Sophie Germain primes (primes where 2p+1 is also prime)
sophie_germain_primes = [p for p in sympy.primerange(3, 10000) if sympy.isprime(2 * p + 1)]

# Generate Cousin primes (primes where p+4 is also prime)
cousin_primes = [(p, p+4) for p in sympy.primerange(3, 10000) if sympy.isprime(p + 4)]

# Extract positions for comparison
sophie_positions = [p for p in sophie_germain_primes[:len(pi_harmonic_shifts)]]
cousin_positions = [p[0] for p in cousin_primes[:len(pi_harmonic_shifts)]]

# Normalize Pi’s harmonic shifts for overlaying
pi_harmonic_shifts_norm = (pi_harmonic_df['Harmonic Shift'] - pi_harmonic_df['Harmonic Shift'].min()) / \
                          (pi_harmonic_df['Harmonic Shift'].max() - pi_harmonic_df['Harmonic Shift'].min())

# Plot Pi Harmonic Shifts vs Sophie Germain & Cousin Primes
plt.figure(figsize=(10, 5))
plt.plot(pi_harmonic_df['Byte Index'][:len(sophie_positions)], pi_harmonic_shifts_norm[:len(sophie_positions)], linestyle='-', color='blue', label="Pi Harmonic Shifts (Normalized)")
plt.scatter(sophie_positions, [0.5] * len(sophie_positions), color='red', marker='x', label="Sophie Germain Primes")
plt.scatter(cousin_positions, [0.6] * len(cousin_positions), color='green', marker='o', label="Cousin Primes")
plt.xlabel("Index")
plt.ylabel("Normalized Value")
plt.title("Pi Harmonic Shifts vs Sophie Germain & Cousin Primes")
plt.legend()
plt.grid(True)
plt.show()

# 3. Look for a fundamental formula that links Pi’s harmonic structure to primes

# Compute ratios between Pi harmonic shifts and twin prime spacing for functional analysis
pi_prime_ratios = aligned_pi_harmonic_shifts / np.array(aligned_twin_prime_gaps[:len(aligned_pi_harmonic_shifts)])

# Fit a potential function to model the relationship
from scipy.optimize import curve_fit

# Define possible function: Logarithmic or Exponential
def log_func(x, a, b):
    return a * np.log(x) + b

def exp_func(x, a, b, c):
    return a * np.exp(-b * x) + c

# Fit the data
x_data = np.array(pi_harmonic_df['Byte Index'][:len(pi_prime_ratios)])
y_data = np.array(pi_prime_ratios)

log_params, _ = curve_fit(log_func, x_data, y_data, maxfev=5000)
exp_params, _ = curve_fit(exp_func, x_data, y_data, maxfev=5000)

# Generate fitted curves
log_fit = log_func(x_data, *log_params)
exp_fit = exp_func(x_data, *exp_params)

# Display fitted function results
fit_results_df = pd.DataFrame({
    'Model': ['Logarithmic', 'Exponential'],
    'Equation': [
        f"{log_params[0]:.4f}ln(x) + {log_params[1]:.4f}",
        f"{exp_params[0]:.4f}e^(-{exp_params[1]:.4f}x) + {exp_params[2]:.4f}"
    ]
})

tools.display_dataframe_to_user(name="Fitted Equations Linking Pi Harmonic Shifts to Prime Gaps", dataframe=fit_results_df)

# Plot fitted function vs actual data
plt.figure(figsize=(10, 5))
plt.scatter(x_data, y_data, color='blue', label="Observed Pi-Prime Ratios")
plt.plot(x_data, log_fit, linestyle='--', color='red', label=f"Log Fit: {log_params[0]:.4f}ln(x) + {log_params[1]:.4f}")
plt.plot(x_data, exp_fit, linestyle='--', color='green', label=f"Exp Fit: {exp_params[0]:.4f}e^(-{exp_params[1]:.4f}x) + {exp_params[2]:.4f}")
plt.xlabel("Byte Index")
plt.ylabel("Pi Harmonic Shift / Prime Gap Ratio")
plt.title("Fitted Functions Linking Pi Harmonic Structure to Prime Gaps")
plt.legend()
plt.grid(True)
plt.show()