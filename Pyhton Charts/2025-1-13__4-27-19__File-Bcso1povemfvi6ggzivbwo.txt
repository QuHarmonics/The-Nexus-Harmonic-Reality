Conversation URL:
https://chatgpt.com/c/6783e51d-5e68-8011-b329-8a8024db41fb

Title:


Prompt:
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d.art3d import Poly3DCollection

def calculate_recursive_shapes(seed_size, recursion_depth=3, sides=4):
    """
    Recursively calculates dimensions and centers for N-sided 3D shapes.

    Args:
        seed_size (float): The size of the initial seed shape.
        recursion_depth (int): Number of recursive layers.
        sides (int): Number of sides for the 3D shape (e.g., 4 for cube).

    Returns:
        list: A list of dictionaries containing size, center, and other properties for each shape.
    """
    shapes = []

    # Initialize the seed shape
    size = seed_size
    center = (0, 0, 0)  # Growth starts at (0, 0, 0)

    for _ in range(recursion_depth):
        shapes.append({"size": size, "center": center, "sides": sides})

        # Growth: Double the size, and keep the center at (0, 0, 0)
        size *= 2

    return shapes


def create_shape_vertices(size, center, sides):
    """
    Creates vertices dynamically for an N-sided shape based on size and center.

    Args:
        size (float): The size of the shape.
        center (tuple): The (x, y, z) coordinates of the shape's center.
        sides (int): Number of sides for the shape (e.g., 4 for cube).

    Returns:
        np.array: Vertices of the shape.
    """
    cx, cy, cz = center
    half_size = size / 2

    if sides == 4:  # Cube
        return np.array([
            [cx - half_size, cy - half_size, cz - half_size],  # Bottom-left-front
            [cx + half_size, cy - half_size, cz - half_size],  # Bottom-right-front
            [cx + half_size, cy + half_size, cz - half_size],  # Top-right-front
            [cx - half_size, cy + half_size, cz - half_size],  # Top-left-front
            [cx - half_size, cy - half_size, cz + half_size],  # Bottom-left-back
            [cx + half_size, cy - half_size, cz + half_size],  # Bottom-right-back
            [cx + half_size, cy + half_size, cz + half_size],  # Top-right-back
            [cx - half_size, cy + half_size, cz + half_size],  # Top-left-back
        ])
    elif sides == 3:  # Tetrahedron
        return np.array([
            [cx, cy, cz + half_size],  # Apex
            [cx - half_size, cy - half_size, cz - half_size],  # Base-left
            [cx + half_size, cy - half_size, cz - half_size],  # Base-right
            [cx, cy + half_size, cz - half_size],  # Base-center
        ])
    else:
        raise ValueError(f"Unsupported shape with {sides} sides.")

def plot_recursive_shapes(shapes):
    """
    Visualizes recursive shapes using their calculated data.

    Args:
        shapes (list): List of dictionaries containing shape properties.
    """
    fig = plt.figure(figsize=(10, 10))
    ax = fig.add_subplot(111, projection='3d')

    def plot_single_shape(ax, vertices, color, alpha, label):
        """
        Plots a single shape using its vertices.

        Args:
            ax: Matplotlib 3D axis.
            vertices (np.array): Vertices of the shape.
            color (str): Color of the shape.
            alpha (float): Transparency of the shape.
            label (str): Label for the shape.
        """
        faces = [
            [vertices[i] for i in [0, 1, 2, 3]],  # Bottom face
            [vertices[i] for i in [4, 5, 6, 7]],  # Top face
            [vertices[i] for i in [0, 1, 5, 4]],  # Side face
            [vertices[i] for i in [2, 3, 7, 6]],  # Side face
            [vertices[i] for i in [1, 2, 6, 5]],  # Side face
            [vertices[i] for i in [0, 3, 7, 4]],  # Side face
        ]
        ax.add_collection3d(Poly3DCollection(faces, color=color, alpha=alpha, edgecolor="k"))
        ax.text(
            np.mean(vertices[:, 0]),
            np.mean(vertices[:, 1]),
            np.mean(vertices[:, 2]),
            label,
            color=color,
        )

    # Assign colors and labels
    colors = ['red', 'blue', 'green', 'purple', 'orange']
    alpha_values = [0.4, 0.3, 0.2, 0.1, 0.05]

    for i, shape in enumerate(shapes):
        size = shape["size"]
        center = shape["center"]
        sides = shape["sides"]

        # Generate vertices dynamically
        vertices = create_shape_vertices(size, center, sides)

        # Plot shape
        color = colors[i % len(colors)]
        alpha = alpha_values[i % len(alpha_values)]
        plot_single_shape(ax, vertices, color, alpha, label=f"Shape {i + 1}")

    # Set plot limits based on the largest shape
    max_size = shapes[-1]["size"]
    ax.set_xlim(-max_size, max_size)
    ax.set_ylim(-max_size, max_size)
    ax.set_zlim(-max_size, max_size)
    ax.set_xlabel("X-axis")
    ax.set_ylabel("Y-axis")
    ax.set_zlabel("Z-axis")
    ax.set_title("Recursive Nested Shapes (Centered and Corrected)")
    plt.show()


# Input seed size, recursion depth, and number of sides (4 for cube, 3 for tetrahedron)
seed_size = 256  # Initial shape size
recursion_depth = 4  # Number of recursive layers
sides = 4  # Number of sides (e.g., 4 for cube)

# Calculate shape properties recursively
shapes = calculate_recursive_shapes(seed_size, recursion_depth, sides)

# Visualize recursive shapes
plot_recursive_shapes(shapes)