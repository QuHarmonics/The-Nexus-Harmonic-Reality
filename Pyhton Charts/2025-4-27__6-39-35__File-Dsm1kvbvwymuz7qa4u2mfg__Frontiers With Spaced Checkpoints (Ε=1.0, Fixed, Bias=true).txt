Conversation URL:
https://chatgpt.com/c/680df8d1-c038-8011-b644-837635a78eee

Title:
Frontiers with Spaced Checkpoints (ε=1.0, fixed, bias=True)

Prompt:
import numpy as np
import matplotlib.pyplot as plt

# Stream generators
def generate_random_walk(N=1000, seed=0):
    np.random.seed(seed)
    return np.cumsum(np.random.randn(N))

def generate_sinusoid(N=1000, freq=5, amplitude=1.0, phase=0.0):
    t = np.linspace(0, 2 * np.pi, N)
    return amplitude * np.sin(freq * t + phase)

def generate_bursty(N=1000, p_burst=0.05, burst_scale=5.0, noise_scale=0.2, seed=42):
    np.random.seed(seed)
    deltas = []
    for _ in range(N):
        if np.random.rand() < p_burst:
            deltas.append(np.random.randn() * burst_scale)
        else:
            deltas.append(np.random.randn() * noise_scale)
    return np.cumsum(deltas)

# Compression: checkpoint every m journal entries
def spaced_checkpoint_compression(stream, base_eps, min_len, max_len, bias, m, k=0.35):
    deltas = np.diff(stream)
    N_main = len(deltas)
    # Journaled deltas
    journal = [d for d in deltas if abs(d) > base_eps]
    
    motif_dict = {}
    next_id = 0
    tokens = []
    storage_tokens = 0
    checkpoints = 0
    since_cp = 0
    
    pos = 0
    while pos < len(journal):
        matched = False
        # motif match
        for L in range(max_len, min_len-1, -1):
            if pos+L <= len(journal):
                seq = tuple(journal[pos:pos+L])
                if seq in motif_dict:
                    tokens.append(('M', motif_dict[seq]))
                    storage_tokens += 1
                    since_cp += 1
                    pos += L
                    matched = True
                    break
        if matched:
            # check spacing
            if since_cp >= m:
                checkpoints += 1
                since_cp = 0
            continue
        
        # literal
        d = journal[pos]
        tokens.append(('D', d))
        storage_tokens += 1
        since_cp += 1
        
        # new motif insertion
        candidates = [tuple(journal[pos:pos+L]) 
                      for L in range(min_len, max_len+1) 
                      if pos+L <= len(journal)]
        if candidates:
            # choose best by bias
            if bias:
                best = min(candidates, key=lambda s: abs(np.mean(s) - k))
                if best not in motif_dict:
                    motif_dict[best] = next_id; next_id+=1
            else:
                for seq in candidates:
                    if seq not in motif_dict:
                        motif_dict[seq] = next_id; next_id+=1
        
        # check spacing
        if since_cp >= m:
            checkpoints += 1
            since_cp = 0
        
        pos += 1
    
    total_storage_ratio = (storage_tokens + checkpoints)/N_main

    # Reconstruction
    reconstructed = np.zeros(len(stream))
    idx = 1
    inv_motifs = {v:k for k,v in motif_dict.items()}
    for typ, val in tokens:
        if typ=='M':
            for d in inv_motifs[val]:
                reconstructed[idx] = reconstructed[idx-1] + d
                idx += 1
        else:
            reconstructed[idx] = reconstructed[idx-1] + val
            idx += 1

    rmse = np.sqrt(np.mean((reconstructed - stream)**2))
    return total_storage_ratio, rmse

# Run for ε=1.0, fixed, bias=True, motif lengths and m spacing
streams = {
    'random': generate_random_walk(),
    'sinusoid': generate_sinusoid(),
    'bursty': generate_bursty()
}
motif_lengths = list(range(2,9))
ms = [25, 50, 100]

results = {name:[] for name in streams}
for name, stream in streams.items():
    for m in ms:
        pts = []
        for min_len in motif_lengths:
            max_len = min_len+3
            sr, rmse = spaced_checkpoint_compression(
                stream, base_eps=1.0, min_len=min_len, max_len=max_len,
                bias=True, m=m
            )
            pts.append((sr, rmse))
        results[name].append((m, np.array(pts)))

# Plot frontiers
plt.figure(figsize=(10,6))
for name, color in zip(streams, ['red','blue','green']):
    for m, data in results[name]:
        x = data[:,0]; y = data[:,1]
        plt.plot(x, y, marker='o', linestyle='-', color=color,
                 label=f'{name}, m={m}')
plt.xlabel('Total Storage Ratio')
plt.ylabel('RMSE')
plt.title('Frontiers with Spaced Checkpoints (ε=1.0, fixed, bias=True)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()