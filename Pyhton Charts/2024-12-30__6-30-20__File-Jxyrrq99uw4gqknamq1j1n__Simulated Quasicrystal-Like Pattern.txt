Conversation URL:
https://chatgpt.com/c/677244df-a740-8011-b1e1-d3bcf912e328

Title:
Simulated Quasicrystal-Like Pattern

Prompt:
# Step 1: Analyze the mathematical properties of the harmonic tile
def analyze_tile_properties(shapes, harmonic_constant=0.35, golden_ratio=(1 + np.sqrt(5)) / 2):
    """
    Analyzes the mathematical properties of the harmonic tile.
    - shapes: List of generated shapes (tiles).
    - harmonic_constant: Compression constant used in the recursion.
    - golden_ratio: Expansion constant used in the recursion.
    """
    properties = []
    for i, shape in enumerate(shapes):
        # Calculate the area of each shape
        area = 0.5 * abs(
            sum(
                shape[j][0] * shape[(j + 1) % len(shape)][1] -
                shape[(j + 1) % len(shape)][0] * shape[j][1]
                for j in range(len(shape))
            )
        )
        # Calculate edge lengths
        edges = [
            np.linalg.norm(shape[j] - shape[(j + 1) % len(shape)])
            for j in range(len(shape))
        ]
        properties.append({
            "Tile Index": i,
            "Area": area,
            "Average Edge Length": np.mean(edges),
            "Harmonic Alignment (Area/H)": area / harmonic_constant,
            "Golden Ratio Alignment (Edge/Ï•)": np.mean(edges) / golden_ratio
        })
    return properties

# Step 2: Test its application in physical systems like quasicrystals
def simulate_quasicrystal_pattern(shapes):
    """
    Simulates a quasicrystal-like pattern using the harmonic tile.
    - shapes: List of generated shapes (tiles).
    """
    fig, ax = plt.subplots(figsize=(10, 10))
    for shape in shapes:
        polygon = plt.Polygon(shape, edgecolor='black', facecolor='orange', alpha=0.5)
        ax.add_patch(polygon)
    ax.set_aspect('equal')
    ax.autoscale_view()
    plt.title("Simulated Quasicrystal-Like Pattern")
    plt.show()

# Step 3: Compare to existing aperiodic tiling solutions (e.g., Einstein Tile)
def compare_to_existing_solutions(shapes, harmonic_constant=0.35):
    """
    Compares the harmonic tile to known aperiodic solutions.
    - shapes: List of generated shapes (tiles).
    - harmonic_constant: Compression constant used in recursion.
    """
    # Comparison metrics
    total_tiles = len(shapes)
    average_area = np.mean([
        0.5 * abs(
            sum(
                shape[j][0] * shape[(j + 1) % len(shape)][1] -
                shape[(j + 1) % len(shape)][0] * shape[j][1]
                for j in range(len(shape))
            )
        ) for shape in shapes
    ])
    average_alignment = np.mean([
        area / harmonic_constant for area in [
            0.5 * abs(
                sum(
                    shape[j][0] * shape[(j + 1) % len(shape)][1] -
                    shape[(j + 1) % len(shape)][0] * shape[j][1]
                    for j in range(len(shape))
                )
            ) for shape in shapes
        ]
    ])
    return {
        "Total Tiles": total_tiles,
        "Average Area": average_area,
        "Average Harmonic Alignment": average_alignment,
        "Single Tile": total_tiles == 1
    }

# Run analyses
harmonic_tile_properties = analyze_tile_properties(harmonic_shapes)
simulate_quasicrystal_pattern(harmonic_shapes)
comparison_results = compare_to_existing_solutions(harmonic_shapes)

# Display the analysis of properties
import pandas as pd
tools.display_dataframe_to_user(name="Harmonic Tile Properties Analysis", dataframe=pd.DataFrame(harmonic_tile_properties))
comparison_results