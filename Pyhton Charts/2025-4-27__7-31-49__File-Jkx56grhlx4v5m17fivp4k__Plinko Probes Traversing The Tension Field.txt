Conversation URL:
https://chatgpt.com/c/680c6ad3-3dac-8011-bbbd-dfa19c2720e8

Title:
Plinko Probes Traversing the Tension Field

Prompt:
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm

def plinko_probe_simulation(field, n_probes=200, max_steps=500, step_size=1):
    """
    Drop `n_probes` into the `field` and let them follow the negative gradient
    (steepest‑descent) until they hit a local minimum or exceed `max_steps`.
    
    Parameters
    ----------
    field : 2‑D numpy.ndarray
        Scalar “tension” field (higher = steeper potential).
    n_probes : int
        Number of probes to drop (default 200).
    max_steps : int
        Maximum path length for each probe (default 500).
    step_size : float
        Gradient step multiplier (default 1).  Smaller → slower descent.
        
    Returns
    -------
    paths : list[list[tuple[int,int]]]
        List of probe paths; each path is a list of (row,col) coordinates.
    """
    # Pre‑compute gradient of the field (simple finite diff)
    gy, gx = np.gradient(field)          # y‑gradient, x‑gradient
    
    n_rows, n_cols = field.shape
    paths = []
    
    rng = np.random.default_rng(42)
    for _ in range(n_probes):
        # Start probe at a random position along the top row
        r, c = 0, rng.integers(0, n_cols)
        path = [(r, c)]
        
        for _ in range(max_steps):
            # Interpolate gradient at current integer position
            # (Nearest‑neighbor is fine for a quick prototype)
            grad_x = gx[int(round(r)), int(round(c))]
            grad_y = gy[int(round(r)), int(round(c))]
            
            # Move against gradient (steepest descent → minus grad)
            r_new = r - step_size * grad_y
            c_new = c - step_size * grad_x
            
            # Boundaries: clamp inside field
            r_new = np.clip(r_new, 0, n_rows - 1)
            c_new = np.clip(c_new, 0, n_cols - 1)
            
            # Stop if stuck (minimal movement) or reached bottom
            if int(round(r_new)) == int(round(r)) and int(round(c_new)) == int(round(c)):
                break
            if int(round(r_new)) == n_rows - 1:
                path.append((int(round(r_new)), int(round(c_new))))
                break
            
            r, c = r_new, c_new
            path.append((int(round(r)), int(round(c))))
        
        paths.append(path)
    
    return paths

# ─────────────────────────────────────────────────────────────
# DEMO SECTION
# If you already have your own `matrix` (e.g. from plot_lean),
# comment out the synthetic field below and pass your matrix in.
# ─────────────────────────────────────────────────────────────
# Synthetic tension field for demonstration (replace with real data)
np.random.seed(0)
demo_field = np.random.rand(128, 128)      # 128×128 random “tension” landscape
demo_field = np.exp(-demo_field)           # make it smoother, positive

# Drop plinko probes
paths = plinko_probe_simulation(demo_field, n_probes=150)

# ─────────────────────────────────────────────────────────────
# VISUALIZE
# ─────────────────────────────────────────────────────────────
plt.figure(figsize=(8, 8))
plt.imshow(demo_field, cmap=cm.viridis, origin='upper', interpolation='nearest')
for path in paths:
    # unpack row/col pairs
    ys, xs = zip(*path)
    plt.plot(xs, ys, alpha=0.3)            # default color sequence, translucent
plt.title("Plinko Probes Traversing the Tension Field")
plt.axis('off')
plt.show()