Conversation URL:
https://chatgpt.com/c/677244df-a740-8011-b1e1-d3bcf912e328

Title:
Outcome-Guided Tile Growth

Prompt:
import matplotlib.pyplot as plt
import numpy as np

def grow_tile(iterations, initial_shape="triangle", golden_ratio=(1 + np.sqrt(5)) / 2):
    """
    Grows a tile based on recursive subdivision, guided by the golden ratio.
    - iterations: Number of recursive growth steps.
    - initial_shape: Starting shape ("triangle" or "rectangle").
    - golden_ratio: Growth constant for proportional relationships.
    """
    shapes = []
    center = np.array([0, 0])  # Initial center
    size = 1  # Initial size

    def generate_triangle(center, size, orientation=0):
        """
        Generates an equilateral triangle based on the center and size.
        """
        angles = np.radians([orientation, orientation + 120, orientation + 240])
        vertices = np.array([
            [center[0] + size * np.cos(angle), center[1] + size * np.sin(angle)]
            for angle in angles
        ])
        return vertices

    def generate_rectangle(center, size, golden_ratio):
        """
        Generates a rectangle based on the center, size, and golden ratio.
        """
        width = size * golden_ratio
        height = size
        half_width = width / 2
        half_height = height / 2
        vertices = np.array([
            [center[0] - half_width, center[1] - half_height],
            [center[0] + half_width, center[1] - half_height],
            [center[0] + half_width, center[1] + half_height],
            [center[0] - half_width, center[1] + half_height],
        ])
        return vertices

    def recursive_subdivide(shape, iteration, golden_ratio):
        """
        Subdivides a given shape recursively.
        """
        if iteration == 0:
            shapes.append(shape)
            return

        # Find the center of the shape
        center = np.mean(shape, axis=0)
        size = np.linalg.norm(shape[1] - shape[0]) / golden_ratio

        if len(shape) == 3:  # Triangle
            for i in range(3):
                new_center = (shape[i] + shape[(i + 1) % 3]) / 2
                new_shape = generate_triangle(new_center, size)
                recursive_subdivide(new_shape, iteration - 1, golden_ratio)
        elif len(shape) == 4:  # Rectangle
            for i in range(4):
                new_center = (shape[i] + shape[(i + 1) % 4]) / 2
                new_shape = generate_rectangle(new_center, size, golden_ratio)
                recursive_subdivide(new_shape, iteration - 1, golden_ratio)

    # Initialize the shape
    if initial_shape == "triangle":
        initial_shape_vertices = generate_triangle(center, size)
    elif initial_shape == "rectangle":
        initial_shape_vertices = generate_rectangle(center, size, golden_ratio)
    else:
        raise ValueError("Unsupported initial shape. Choose 'triangle' or 'rectangle'.")

    # Start the recursive subdivision
    recursive_subdivide(initial_shape_vertices, iterations, golden_ratio)

    return shapes

# Visualize the generated tile
def visualize_tile(shapes):
    fig, ax = plt.subplots(figsize=(8, 8))
    for shape in shapes:
        polygon = plt.Polygon(shape, edgecolor='black', facecolor='skyblue', alpha=0.7)
        ax.add_patch(polygon)
    ax.set_aspect('equal')
    ax.autoscale_view()
    plt.title("Outcome-Guided Tile Growth")
    plt.show()

# Generate and visualize a recursive tile
recursive_shapes = grow_tile(iterations=4, initial_shape="triangle")
visualize_tile(recursive_shapes)